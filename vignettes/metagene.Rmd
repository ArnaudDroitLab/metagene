---
title: "metagene: a package to produce metagene plots"
author: "Charles Joly Beauparlant"
date: "`r Sys.Date()`"
output:
   BiocStyle::html_document:
     toc: true
vignette: >
  %\VignetteIndexEntry{Introduction to metagene}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

`metagene`: a package to produce aggregation plots
========================================================

```{r style, echo = FALSE, results = 'asis', message = FALSE}
BiocStyle::markdown()
library(knitr)
```

**Package**: `r Biocpkg("metagene")`<br />
**Authors**: `r eval(parse(text = packageDescription("metagene")[["Author@R"]]))`<br />
**Modified**: 18 september, 2015<br />
**Compiled**: `r date()`<br />
**License**: `r packageDescription("metagene")[["License"]]`<br />

## Introduction

This package produces metagene-like plots to compare the behavior of
DNA-interacting proteins at selected groups of features. A typical analysis
can be done in viscinity of transcription start sites (TSS) of genes or at any
regions of interest (such as enhancers). Multiple combinations of group of
features and/or group of bam files can be compared in a single analysis.
Bootstraping analysis is used to compare the groups and locate regions with
statistically different enrichment profiles. In order to increase the
sensitivity of the analysis, alignment data is used instead of peaks produced
with peak callers (i.e.: MACS2 or PICS). The metagene package uses bootstrap
to obtain a better estimation of the mean enrichment and the confidence
interval for every group of samples.

This vignette will introduce all the main features of the metagene package.

## Loading metagene package

```{r libraryLoad, message = FALSE}
library(metagene)
```

## Inputs

### Alignment files (BAM files)

There is no hard limit in the number of BAM files that can be included in an
analysis (but with too many BAM files, memory may become an issue). BAM files
must be indexed. For instance, if you use a file names `file.bam`, a file
named `file.bam.bai` must be present in the same directory.

The path (relative or absolute) to the BAM files must be in a vector:
```{r bamFiles}
bam_files <- get_demo_bam_files()
bam_files
```

For this demo, we have 2 samples (each with 2 replicates). It is also possible
to use a named vector to add your own names to each BAM files:
```{r namedBamFiles}
named_bam_files <- bam_files
names(named_bam_files) <- letters[seq_along(bam_files)]
named_bam_files
```

Using named BAM files can simplify the use of the metagene helper functions and
the creation of the design.

### Genomic regions

#### BED files

To compare custom regions of interest, it is possible to use a list of one or
more BED files.

```{r regionsArgument}
regions <- get_demo_regions()
regions
```

The name of the files (without the extension) will be used to name each groups.

`metagene` also support the [narrowPeak](https://genome.ucsc.edu/FAQ/FAQformat.html#format12)
and the [broadPeak](https://genome.ucsc.edu/FAQ/FAQformat.html#format13).

#### GRanges or GRangesList objects - Regions

As an alternative to a list of BED files, `GRanges` or `GRangesList` objects can
be used.

#### Available datasets

Some common datasets are already available with the `metagene` package:

* `promoters_hg19`
* `promoters_hg18`
* `promoters_mm10`
* `promoters_mm9`

```{r showDatasets}
data(promoters_hg19)
promoters_hg19
```

For more details about each datasets, please refer to their documentation (i.e.:
`?promoters_hg19`).

### Design groups

A design group contains a set of BAM files that, when put together, represent
a logical analysis. Furthermore, a design group contains the relationship
between every BAM files present. Samples (with or without replicates) and
controls can be assigned to a same design group. There can be as many groups
as necessary. A BAM file can be assigned to more than one group.

To represent the relationship between every BAM files, design groups must have
the following columns:

* The list of paths to every BAM files related to an analysis.
* One column per group of files (replicates and/or controls).

There is two possible way to create design groups, by reading a file or by
directly creating a design object in R.

#### Design groups from a file

Design groups can be loaded into the metagene package by using a text file. As
the relationship between BAM files as to be specified, the following columns
are mandatory:

* First column: The list of paths (absolute or relative) to every BAM files
for all the design groups, the BAM filenames or the BAM names (if a named BAM.
file was used).
* Following columns: One column per design group (replicates and/or controls).
The column can take only three values:
	+ 0: ignore file
	+ 1: input
	+ 2: control

The file must also contain a header. It is recommanded to use `Samples` for the
name of the first column, but the value is not checked. The other columns in
the design file will be used for naming design groups, and must be unique.

```{r designFile}
fileDesign <- system.file("extdata/design.txt", package="metagene")
design <- read.table(fileDesign, header=TRUE, stringsAsFactors=FALSE)
design$Samples <- paste(system.file("extdata", package="metagene"),
                        design$Samples, sep="/")
kable(design)
```

#### Design groups from R

It is not obligatory to use a design file, you can create the design
`data.frame` using your prefered method (as long as the restrictions on the
values mentioned previously are respected).

For instance, the previous design data.frame could have been create directly
in R:
```{r alternateDesign}
design <- data.frame(Samples = c("align1_rep1.bam", "align1_rep2.bam",
                            "align2_rep1.bam", "align2_rep2.bam", "ctrl.bam"),
		                    align1 = c(1,1,0,0,2), align2 = c(0,0,1,1,2))
design$Samples <- paste0(system.file("extdata", package="metagene"), "/",
                            design$Samples)
kable(design)
```

## Analysis steps

A typical metagene analysis will consist steps:

* Extraction the read count of every BAM files in selected regions.
* Conversion in coverage.
* Noise removal
* Normalization of the coverage values.
* Statistical analysis.
* Generation of the metagene plot.

To facilitate the analysis, all those steps managed by a metagene object. A
typical analysis will require 3 steps:

1. Initialization of the metagene object: during this step, the metagene object
will produce the coverages for every regions specified and for every
BAM files.
2. Production of the matrices: To produce the metagene plot, the normalized
coverages must be converted in a matrix where the columns represent the
positions and the rows the regions. With simple experimental design (i.e.: no
control and no replicate), this step can be ignored since the `plot` function is
able to produce the matrices with default param if no matrices are found (see
the `Plotting results` section below for a concrete example). During this step:
  * The background is removed
  * The replicates are merged
  * The matrices are created.
3. Plotting: during this step, the metagene object will perform
the statistical analysis necessary to obtain a robust estimate of the mean
and its confidence interval for every group of regions and will show the
results in a metagene plot.

### Generating coverages

To extract coverages, the user must initialize the metagene object. The minimal
requirements for this step is a list of bam files and a list of regions:
```{r initializeMetageneObj}
mg <- metagene$new(regions = regions, bam_files = bam_files)
```

### Plotting results

The statistical analysis and the production of the metagene plot are done
in a single step with the function `plot` of the metagene object. In this
specific case, we know that all the regions have the same size and are all
centered on the same element. We can specify this information with the `range`
parameter.

```{r producePlotEx1}
results <- mg$plot(range = c(-1000,1000), title = "Demo metagene plot")
```

As you can see, the current plot is messy since by default
`r Biocpkg("metagene")` will produce a curve for each possible combination of
BAM file and region groups. In this case, we have `r length(bam_files)` BAM
files and `r length(regions)` regions, which gives us
`r length(bam_files) * length(regions)` curves.

We can also use the design we produced earlier to remove background signal and
combine replicates:
```{r produceMatricesDesign}
mg$produce_matrices(design = design)
results <- mg$plot(range = c(-1000,1000), title = "Show design")
```

The `plot` function returns a `list` containing the `data.frame` used by
`ggplot2` to produce the results:
```{r showDataFrame, collapse=TRUE}
class(results)
names(results)
head(results$DF)
```

## Manipulating `metagene` objects

### Getters

Multiple getters functions are available to access the data that is stored in a `metagene` object.

#### `get_params`

The various parameters used during the initialization of the `metagene` object, the production of the matrices and the production of the plot are saved and can be accessed with the `get_params` function:
```{r getParams}
mg <- get_demo_metagene()
mg$get_params()
```

#### `get_design`

To get the design that was used to produce the last version of the matrices, you can use the `get_design` function:
```{r getDesign}
mg$produce_matrices(design = get_demo_design())
## Alternatively, it is also possible to add a design without producing the
## matrices:
#mg$add_design(get_demo_design())
mg$get_design()
```

#### `get_bam_count`

To get the number of aligned read in a BAM file, you can use the `get_bam_count` function:
```{r getBamCount}
mg$get_bam_count(bam_files[1])
```

#### `get_regions`

To get all the regions, you can use the `get_regions` function:
```{r getRegions}
mg$get_regions()
```

It is also possible to extract a subset of the regions with the `get_regions` function:
```{r getRegionsSubset}
mg$get_regions(region_names = c(regions[1]))
```

#### `get_raw_coverages`

To get the coverages produced during the initialization of the `metagene` object, you can use the `get_raw_coverages` function. Please note that to save space, metagene will only extract the coverages in the regions provided.

```{r getRawCoverages}
coverages <- mg$get_raw_coverages()
coverages[[1]]
length(coverages)
```

It is also possible to extract a subset of all the coverages by providing the filenames:

```{r getRawCoveragesSubset}
coverages <- mg$get_raw_coverages(filenames = bam_files[1:2])
length(coverages)
```

#### `get_normalized_coverages`

The `get_normalized_coverages` function works exactly like the `get_raw_coverages` function except that it returns the coverages in read per million aligned (RPM).
